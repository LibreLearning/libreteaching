\section{Development Tools}

\section{GCC: The GNU Compiler Collection}

\begin{frame}
  \frametitle{Introduction}

  \begin{itemize}
  \item Originally named the GNU C Compiler, since it only handled
    the C programming language
  \item Today is a compiler system supporting various programming
    languages (C/C++, Java, ADA, Objective-C, Objective-C++, Fortran)
  \item Started by Richard Stallman in 1985
  \item Used in lots of platforms including embedded platforms
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Compiling a C program}
\begin{verbatim}
$ gcc -g -Wall test.c -o test
\end{verbatim}
  Recommended flags
  \begin{itemize}
  \item -g: Produce debugging information
  \item -Wall: Turns on all optional warnings which are desirable for
    normal code
  \item -o: Write output to file
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Compiling multi-file programs}

  One step
\begin{verbatim}
$ gcc -g -Wall -o test test-helper.c test.c
\end{verbatim}

  Compiling every file in a different step
\begin{verbatim}
$ gcc -g -Wall -c test-helper.c # test-helper.o
$ gcc -g -Wall -c test.c        # test.o
$ gcc -o test test-helper.o test.o
\end{verbatim}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Linking}

  External libraries
\begin{verbatim}
$ gcc -o test test-helper.o test.o -lm
\end{verbatim}

  Library search path
  \begin{itemize}
  \item -Lpath
  \item Default: /usr/lib, /usr/local/lib
  \item Env variable: LD\_LIBRARY\_PATH
  \end{itemize}

  Include search path
  \begin{itemize}
  \item -Ipath
  \item Default: /usr/include /usr/local/include
  \item Env variable: C\_INCLUDE\_PATH
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Static and Shared libraries}

  \begin{itemize}
  \item Static: included into the binary executable (in UNIX .a)
  \item Dynamic: loaded into the program at runtime (in UNIX .so)
  \end{itemize}

  Dynamic libraries are the default option when available. The static
  linking can be forced by using the --static flag when compiling with
  gcc.
\end{frame}

\begin{frame}
  \frametitle{pkg-config: metainformation about installed libraries}

  Common options used for compiling
  \begin{itemize}
  \item --cflags: prints pre-processor and compile flags required to
    compile
  \item --libs: prints the link flags
  \end{itemize}

  Options to get information about a library
  \begin{itemize}
  \item --modversion: prints the version of the installed library
  \item --exists
  \item --atleast-version=VERSION
  \item --exact-version=VERSION
  \item --max-version=VERSION
  \end{itemize}

  Option to get the list of installed libraries
  \begin{itemize}
  \item --list-all
  \end{itemize}
\end{frame}

\section{Automatic building}

\begin{frame}[fragile]
  \frametitle{Makefile}

  \begin{itemize}
  \item Text file used by the make command
  \item Consists of rules with the following shape:
\begin{verbatim}
target: dependencies
    commands
\end{verbatim}

    \begin{itemize}
    \item target: the name of an output file or another action to be
      carried out
    \item dependencies: target prerequisites needed to run the command
    \item commands: action that is finally carried out
    \end{itemize}

  \item Once the Makefile is created we can run the make command
\begin{verbatim}
$ make target
\end{verbatim}
  \item By default, make starts with the first target. 
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Writing Makefiles}
  \begin{itemize}
  \item We can use variables like in a shell script with \$(variable)
  \item Wildcard characters ('*', '?' and '[..]' like in bash)
  \item Pattern Rules (with \% character)
\begin{verbatim}
$ target: target-pattern: prereq-patterns
    commands
\end{verbatim}
  \item Some special variables
    \begin{itemize}
    \item \$@: current target name
    \item \$<: first prerequisite of the current rule
    \item \$\^~: the list of prerequisites of the current rule
    \item \$+: the list of prerequisites of the current rule including
      duplicates
    \item \$?: the list of prerequisites that are newer than the target
    \end{itemize}

  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{GNU Autotools}
  Set of tools for creating a building system for a software package
  \begin{itemize}
  \item Autoconf: produces shell scripts that automatically configure
    software source code packages
  \item Automake: produces Makefile.in files 
  \item Libtool: creates portable libraries
  \item Gettext: internationalization 
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Autoconf}
  \begin{itemize}
  \item Scripts generated by autoconf don't depend on autoconf to be run
  \item Based on macros and templates it generates a configure script
    suitable for you software package which doesn't need any further
    modification
  \item Autoconf creates the configure script by using another script written by
    the user (commonly named configure.ac or configure.in)
  \item And finally the configure script converts Makefile.in files
    into final Makefiles that can be processed with make
  \item In order to create a complete and portable build system
    autoconf should be used in combination with other tools like Automake
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Automake}
  \begin{itemize}
  \item Creates Makefile.in files from Makefile.am files written by
    the user.
  \item It makes writing Makefiles easier and simpler
  \item Automatically generates dependencies so that files are not
    always recompiled, but only when they have changed
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{pkg-config: Autoconf macros}
{\tiny
\begin{verbatim}
  PKG_CHECK_MODULES(VARIABLE-PREFIX,MODULES[,ACTION-IF-FOUND,[ACTION-IF-NOT-FOUND]])
\end{verbatim}
}
\begin{itemize}
\item The most commonly used pkg-config Autoconf macro
\item Checks whether a module exists
\item Generates \_CFLAG and \_LIBS substitution variables, set to the
  libs and cflags for the given module list
\item Default action is to abort when a module is not found or has
  wrong version
\end{itemize}
{\tiny
\begin{verbatim}
PKG_CHECK_MODULES([MY_PROJECT], [glib-2.0 >= 2.1.5 libxml-2.0 >= 2.0.0])
\end{verbatim}
}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Hello world example: configure.ac}
\begin{verbatim}
dnl Process this file with autoconf to produce 
dnl a configure script.

AC_INIT([hello], [0.1])

AM_INIT_AUTOMAKE([1.9])
AC_PROG_CC
AC_CONFIG_HEADERS([config.h])
AC_CONFIG_FILES([
Makefile
src/Makefile
])
AC_OUTPUT
\end{verbatim}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Hello world example: Makefiles}
  Makefile.am
\begin{verbatim}
SUBDIRS=src
\end{verbatim}
  src/Makefile.am
\begin{verbatim}
bin_PROGRAMS=hello
hello_SOURCES=main.c
\end{verbatim}

\end{frame}

\begin{frame}[fragile]
  \frametitle{Hello world with dependencies example: configure.ac}
{\scriptsize
\begin{verbatim}
dnl Process this file with autoconf to produce 
dnl a configure script.

AC_INIT([hello], [0.1])

AM_INIT_AUTOMAKE([1.9])
AC_PROG_CC
AM_PROG_CC_C_O
AC_CONFIG_HEADERS([config.h])

PKG_CHECK_MODULES([HELLO], [glib-2.0])
AC_SUBST(HELLO_CFLAGS)
AC_SUBST(HELLO_LIBS)

AC_CONFIG_FILES([
Makefile
src/Makefile
])
AC_OUTPUT
\end{verbatim}
}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Hello world with dependencies example: Makefiles}

  src/Makefile.am
\begin{verbatim}
bin_PROGRAMS=hello
hello_SOURCES=main.c
hello_CPPFLAGS=$(HELLO_CFLAGS)
hello_LDADD=$(HELLO_LIBS)
\end{verbatim}
\end{frame}

